@startuml


package "Presentation Layer"  {
    interface LinterUI {
        ~ displayResults(violations: List<Violation>): void
        ~ getFolderPath(): String
        ~ getChecksSelectionInput(): String
    }

    class ConsoleUI {
        + displayResults(violations: List<Violation>): void
        + getFolderPath(): String
        + getChecksSelectionInput(): String
    }

    class Main {
        + main(args: String[]): void
    }
}


package "Domain Layer"  {

    package "Internal Representation"  {
        class ClassInfo {
            - name: String
            - fields: List<FieldInfo>
            - methods: List<MethodInfo>
            - interfaces: List<String>
            - superClass: String
            - isPublic: boolean
            - isInterface: boolean
            - isAbstract: boolean
            - isEnum: boolean
            + getName(): String
            + getFields(): List<FieldInfo>
            + getMethods(): List<MethodInfo>
            + getInterfaces(): List<String>
            + getSuperClass(): String
            + isPublic(): boolean
            + isInterface(): boolean
            + isAbstract(): boolean
            + isEnum(): boolean
            + isConcrete(): boolean
            + hasMethod(name: String): boolean
        }

        class MethodInfo {
            - name: String
            - className: String
            - returnType: String
            - isPublic: boolean
            - isStatic: boolean
            - localVariables: List<LocalVariableInfo>
            + getName(): String
            + getClassName(): String
            + getReturnType(): String
            + isPublic(): boolean
            + isStatic(): boolean
            + getLocalVariables(): List<LocalVariableInfo>
        }

        class FieldInfo {
            - name: String
            - className: String
            - type: String
            - isPublic: boolean
            - isFinal: boolean
            + getName(): String
            + getClassName(): String
            + getType(): String
            + isPublic(): boolean
            + isFinal(): boolean
        }

        class LocalVariableInfo {
            - name: String
            - type: String
            + getName(): String
            + getType(): String
        }

        class Context {
            - classes: List<ClassInfo>
            - dependencyInfo: DependencyInfo
            - folderPath: String
            - classBytecode: Map<String, byte[]>
            + getClasses(): List<ClassInfo>
            + getDependencyInfo(): DependencyInfo
            + getFolderPath(): String
            + getClassBytecode(className: String): byte[]
            + getBytecodeMap(): Map<String, byte[]>
            + getClassCount(): int
        }

        class DependencyInfo {
            - adjacencyMatrix: DependencyType[][]
            - classNameToIndex: Map<String, Integer>
            - size: int
            + getDependency(fromClass: String, toClass: String): DependencyType
            + setDependency(fromClass: String, toClass: String, type: DependencyType): void
            + getClassIndex(className: String): int
            + getSize(): int
        }

        enum DependencyType {
            NONE
            IS_A
            HAS_A
            IMPLEMENTS
            GENERAL
            HAS_MANY
        }
    }

    interface LintCheck  {
        + analyze(context: Context): List<Violation>
        + getName(): String
        + getDescription(): String
    }


    abstract class PerClassLintCheck <<Template Method>> {
        + {final} analyze(context: Context): List<Violation>
        # checkClass(classInfo: ClassInfo): Optional<Violation>
        # checkField(field: FieldInfo): Optional<Violation>
        # checkMethod(method: MethodInfo): Optional<Violation>
        # checkLocalVariable(variable: LocalVariableInfo, method: MethodInfo): Optional<Violation>
}

    class EqualsHashCodeCheck {
        # checkClass(classInfo: ClassInfo): Optional<Violation>
    }

    class PublicMutableFieldsCheck {
        # checkField(field: FieldInfo): Optional<Violation>
    }

    class HasPublicConstructorCheck{
         # checkClass(classInfo: ClassInfo): Optional<Violation>
    }

    class NamingConventionCheck {
        # checkClass(classInfo: ClassInfo): Optional<Violation>
        # checkField(field: FieldInfo): Optional<Violation>
        # checkMethod(method: MethodInfo): Optional<Violation>
        # checkLocalVariable(variable: LocalVariableInfo, method: MethodInfo): Optional<Violation>
    }

    class RedundantInterfacesCheck {
        + analyze(context: Context): List<Violation>
        - collectParentInterfaces(ClassInfo classInfo, Map<String, ClassInfo> classMap): Set<String>
    }

    class CircularDependencyCheck {
        + analyze(context: Context): List<Violation>
        - detectCycle(String currentClass, DependencyInfo dependencyInfo, List<ClassInfo> classes,
        Set<String> visitedInPath, List<String> path, Set<String> globalVisited, List<Violation> violations)
    }

    class GenerateUML {
        + analyze(context: Context): List<Violation>
        - generatePlantUmlDiagram(Context context): String
        - generateClassDefinition(String className, byte[] bytecode, Path tempDir): String
        - generateDependencyRelationships(Context context): String
        - getPlantUmlArrow(DependencyType type): String
        - writePlantUmlFile(String folderPath, String content): void
        - deleteDirectory(File directory): void
    }

    class Violation {
        - {final} checkName: String
        - {final} className: String
        - {final} message: String
        + getCheckName(): String
        + getClassName(): String
        + getMessage(): String
        + toString(): String
    }

    class LintEngine {
        - checks: List<LintCheck>
        + LintEngine(String input)
        + getCheckCount(): int
        + analyzeAll(context: Context): List<Violation>
    }
}


package "Data Source Layer" {

    interface DataModelConverter <<Target>> {
        + buildContext(classFiles: Map<String, byte[]>, folderPath: String): Context
    }

    class AsmConverter <<Adapter>> {
        - adaptee: AsmLibrary
        + buildContext(classFiles: Map<String, byte[]>, folderPath: String): Context
    }

    class AsmLibrary <<Adaptee>> {
        ~ readClassNode(bytes: byte[]): ClassNode
        ~ getFields(classNode: ClassNode): List<FieldNode>
        ~ getMethods(classNode: ClassNode): List<MethodNode>
    }

    class DataLoader {
        + loadClassFiles(folderPath: String): Map<String, byte[]>
    }
}


ConsoleUI ..|> LinterUI
Main --> ConsoleUI
Main --> LintEngine
Main --> DataModelConverter
Main --> DataLoader


ClassInfo -->"*" MethodInfo
ClassInfo -->"*" FieldInfo
MethodInfo -->"*" LocalVariableInfo
Context -->"*" ClassInfo
Context --> DependencyInfo

PerClassLintCheck ..|> LintCheck
EqualsHashCodeCheck --|> PerClassLintCheck
PublicMutableFieldsCheck --|> PerClassLintCheck
NamingConventionCheck --|> PerClassLintCheck
RedundantInterfacesCheck ..|> LintCheck
CircularDependencyCheck ..|> LintCheck
GenerateUML ..|> LintCheck
HasPublicConstructorCheck --|> PerClassLintCheck

LintCheck..> Violation
EqualsHashCodeCheck..> Violation
PublicMutableFieldsCheck..> Violation
NamingConventionCheck..> Violation
RedundantInterfacesCheck..> Violation
CircularDependencyCheck..> Violation
GenerateUML..> Violation

NamingConventionCheck ..> ClassInfo
NamingConventionCheck ..> MethodInfo
NamingConventionCheck ..> FieldInfo
NamingConventionCheck ..> LocalVariableInfo

EqualsHashCodeCheck..> ClassInfo
HasPublicConstructorCheck..> ClassInfo

PublicMutableFieldsCheck..> FieldInfo

GenerateUML..> Context
RedundantInterfacesCheck..> Context
CircularDependencyCheck..> Context
LintCheck..> Context

DependencyInfo -->"*" DependencyType

AsmConverter ..> Context
DataModelConverter ..> Context

LintEngine -->"*" LintCheck
LintEngine ..> Violation
LintEngine ..> Context

AsmConverter ..|> DataModelConverter
AsmConverter --> AsmLibrary

note bottom of PerClassLintCheck
A defined traversal over the class, its methods and its fields.
Children can override specific checks related to its behavior
end note


note left of Main
<b>Flow:</b>
1. Get folder path via ConsoleUI
2. Load .class files using DataLoader
3. Build Context using DataModelConverter
4. Get checks input via ConsoleUI
5. Create and run LintEngine.analyzeAll(context)
6. Display results via ConsoleUI
end note

note top of AsmConverter
This class implements an Adapter that wraps
an external library behind our internal objects so the domain
layer never depends on third-party objects.
end note

@enduml