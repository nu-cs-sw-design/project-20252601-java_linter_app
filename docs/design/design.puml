@startuml


package "Presentation Layer"  {
    interface LinterUI {
        ~ displayResults(violations: List<Violation>): void
        ~ getFolderPath(): String
        ~ configureChecks(engine: LintEngine): void
    }

    class ConsoleUI {
        + displayResults(violations: List<Violation>): void
        + getFolderPath(): String
        + configureChecks(engine: LintEngine): void
        - addAllChecks(engine: LintEngine): void
        - addCheck(engine: LintEngine, checkNumber: int): void
    }

    class Main {
        + main(args: String[]): void
    }
}


package "Domain Layer"  {

    package "Internal Representation"  {
        class ClassInfo {
            - name: String
            - fields: List<FieldInfo>
            - methods: List<MethodInfo>
            - interfaces: List<String>
            - superClass: String
            - isPublic: boolean
            + getName(): String
            + getFields(): List<FieldInfo>
            + getMethods(): List<MethodInfo>
            + getInterfaces(): List<String>
            + getSuperClass(): String
            + isPublic(): boolean
            + hasMethod(name: String): boolean
        }

        class MethodInfo {
            - name: String
            - className: String
            - returnType: String
            - isPublic: boolean
            - isStatic: boolean
            - localVariables: List<LocalVariableInfo>
            + getName(): String
            + getClassName(): String
            + getReturnType(): String
            + isPublic(): boolean
            + isStatic(): boolean
            + getLocalVariables(): List<LocalVariableInfo>
        }

        class FieldInfo {
            - name: String
            - className: String
            - type: String
            - isPublic: boolean
            - isFinal: boolean
            + getName(): String
            + getClassName(): String
            + getType(): String
            + isPublic(): boolean
            + isFinal(): boolean
        }

        class LocalVariableInfo {
            - name: String
            - type: String
            + getName(): String
            + getType(): String
        }

        class Context {
            - classes: List<ClassInfo>
            - dependencyInfo: DependencyInfo
            - folderPath: String
            - classBytecode: Map<String, byte[]>
            + getClasses(): List<ClassInfo>
            + getDependencyInfo(): DependencyInfo
            + getFolderPath(): String
            + getClassBytecode(className: String): byte[]
            + getBytecodeMap(): Map<String, byte[]>
            + getClassCount(): int
        }

        class DependencyInfo {
            - adjacencyMatrix: DependencyType[][]
            - classNameToIndex: Map<String, Integer>
            - size: int
            + getDependency(fromClass: String, toClass: String): DependencyType
            + setDependency(fromClass: String, toClass: String, type: DependencyType): void
            + getClassIndex(className: String): int
            + getSize(): int
        }

        enum DependencyType {
            NONE
            IS_A
            HAS_A
            IMPLEMENTS
            GENERAL
            HAS_MANY
        }
    }

    interface LintCheck  {
        + analyze(context: Context): List<Violation>
        + getName(): String
        + getDescription(): String
    }


    abstract class PerClassLintCheck <<Template Method>> {
        + {final} analyze(context: Context): List<Violation>
        # checkClass(classInfo: ClassInfo): Optional<Violation>
        # checkField(field: FieldInfo): Optional<Violation>
        # checkMethod(method: MethodInfo): Optional<Violation>
        # checkLocalVariable(variable: LocalVariableInfo, method: MethodInfo): Optional<Violation>
}

    class EqualsHashCodeCheck {
        # checkClass(classInfo: ClassInfo): Optional<Violation>
    }

    class PublicMutableFieldsCheck {
        # checkField(field: FieldInfo): Optional<Violation>
    }

    class HasPublicConstructorCheck{

    }

    class NamingConventionCheck {
        # checkClass(classInfo: ClassInfo): Optional<Violation>
        # checkField(field: FieldInfo): Optional<Violation>
        # checkMethod(method: MethodInfo): Optional<Violation>
        # checkLocalVariable(variable: LocalVariableInfo, method: MethodInfo): Optional<Violation>
    }

    class RedundantInterfacesCheck {
        + analyze(context: Context): List<Violation>
    }

    class CircularDependencyCheck {
        + analyze(context: Context): List<Violation>
    }

    class GenerateUML {
        + analyze(context: Context): List<Violation>
    }

    class Violation {
        - {final} checkName: String
        - {final} className: String
        - {final} message: String
        + getCheckName(): String
        + getClassName(): String
        + getMessage(): String
        + toString(): String
    }

    class LintEngine {
        - checks: List<LintCheck>
        + addCheck(check: LintCheck): void
        + getCheckCount(): int
        + analyzeAll(context: Context): List<Violation>
    }
}


package "Data Source Layer" {

    interface DataModelConverter <<Target>> {
        + buildContext(classFiles: Map<String, byte[]>, folderPath: String): Context
    }

    class AsmConverter <<Adapter>> {
        - adaptee: AsmLibrary
        + buildContext(classFiles: Map<String, byte[]>, folderPath: String): Context
    }

    class AsmLibrary <<Adaptee>> {
        ~ readClassNode(bytes: byte[]): ClassNode
        ~ getFields(classNode: ClassNode): List<FieldNode>
        ~ getMethods(classNode: ClassNode): List<MethodNode>
    }

    class DataLoader {
        + loadClassFiles(folderPath: String): Map<String, byte[]>
    }
}


ConsoleUI ..|> LinterUI
Main --> ConsoleUI
Main --> LintEngine
Main --> DataModelConverter
Main --> DataLoader


ClassInfo -->"*" MethodInfo
ClassInfo -->"*" FieldInfo
MethodInfo -->"*" LocalVariableInfo
Context -->"*" ClassInfo
Context --> DependencyInfo

PerClassLintCheck ..|> LintCheck
EqualsHashCodeCheck --|> PerClassLintCheck
PublicMutableFieldsCheck --|> PerClassLintCheck
NamingConventionCheck --|> PerClassLintCheck
RedundantInterfacesCheck ..|> LintCheck
CircularDependencyCheck ..|> LintCheck
GenerateUML ..|> LintCheck
HasPublicConstructorCheck --|> PerClassLintCheck

LintCheck..> Violation
EqualsHashCodeCheck..> Violation
PublicMutableFieldsCheck..> Violation
NamingConventionCheck..> Violation
RedundantInterfacesCheck..> Violation
CircularDependencyCheck..> Violation
GenerateUML..> Violation

NamingConventionCheck ..> ClassInfo
NamingConventionCheck ..> MethodInfo
NamingConventionCheck ..> FieldInfo
NamingConventionCheck ..> LocalVariableInfo

EqualsHashCodeCheck..> ClassInfo

PublicMutableFieldsCheck..> FieldInfo

GenerateUML..> Context
RedundantInterfacesCheck..> Context
CircularDependencyCheck..> Context
LintCheck..> Context

DependencyInfo -->"*" DependencyType

AsmConverter ..> Context
DataModelConverter ..> Context

LintEngine -->"*" LintCheck
LintEngine ..> Violation
LintEngine ..> Context

AsmConverter ..|> DataModelConverter
AsmConverter --> AsmLibrary

note right of PerClassLintCheck
A defined traversal over the class, its methods and its fields.
Children can override specific checks related to its behavior
end note


note left of Main
<b>Flow:</b>
1. Get folder path via ConsoleUI
2. Load .class files using DataLoader
3. Build Context using DataModelConverter
4. Configure checks via ConsoleUI
5. Run LintEngine.analyzeAll(context)
6. Display results via ConsoleUI
end note

@enduml